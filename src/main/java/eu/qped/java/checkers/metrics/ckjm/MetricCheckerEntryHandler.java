package eu.qped.java.checkers.metrics.ckjm;

import eu.qped.java.checkers.metrics.data.report.ClassMetricsEntry;
import eu.qped.java.checkers.metrics.data.report.ClassMetricsMessage;
import eu.qped.java.checkers.metrics.data.report.ClassMetricsMessageMulti;
import eu.qped.java.checkers.metrics.data.report.ClassMetricsMessageSingle;
import gr.spinellis.ckjm.CkjmOutputHandler;
import gr.spinellis.ckjm.ClassMetrics;
import lombok.Getter;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import static eu.qped.java.checkers.metrics.ckjm.MetricCheckerEntryHandler.Metric.*;

/**

 Class is used to handle the output generated by the checker/ckjm.

 The output is saved in a List of {@link ClassMetricsEntry}s.

 <p>The class implements the {@link CkjmOutputHandler} interface and overrides the
 {@link CkjmOutputHandler#handleClass(String, ClassMetrics)} method to handle the output

 generated by the checker/ckjm for each class.

 <p>The class creates a list of {@link ClassMetricsMessage} for each class that contains
 all the metrics values for the class. The list is then added to a {@link ClassMetricsEntry}

 object, which holds the name of the class and the list of metrics. The ClassMetricsEntry object

 is then added to the list of outputMetrics.

 @author Jannik Seus
 */@Getter
public class MetricCheckerEntryHandler implements CkjmOutputHandler {

    /**

     The list of class metrics entries, containing the name of the class and the metrics values
     */
    private final List<ClassMetricsEntry> outputMetrics;

    /**

     The constructor, initializes the outputMetrics variable with an empty ArrayList
     */
    public MetricCheckerEntryHandler() {
        this.outputMetrics = new ArrayList<>();
    }

    /**

     Handles the output generated by the checker/ckjm for each class.

     <p>This method creates a list of {@link ClassMetricsMessage} for each class that contains
     all the metrics values for the class. The list is then added to a {@link ClassMetricsEntry}

     object, which holds the name of the class and the list of metrics. The ClassMetricsEntry object

     is then added to the list of outputMetrics.

     @param className the name of the class

     @param cMetrics the class metrics generated by the checker/ckjm
     */
    @Override
    public void handleClass(final String className, final ClassMetrics cMetrics) {

        final List<ClassMetricsMessage> metricsForClass = new ArrayList<>();

        final Map<String, Integer> metricValuesCC = getCCMapInternal(cMetrics);

        metricsForClass.add(new ClassMetricsMessageSingle(AMC, cMetrics.getAmc()));
        metricsForClass.add(new ClassMetricsMessageSingle(CA, cMetrics.getCa()));
        metricsForClass.add(new ClassMetricsMessageSingle(CAM, cMetrics.getCam()));
        metricsForClass.add(new ClassMetricsMessageSingle(CBM, cMetrics.getCbm()));
        metricsForClass.add(new ClassMetricsMessageSingle(CBO, cMetrics.getCbo()));
        metricsForClass.add(new ClassMetricsMessageMulti(CC, metricValuesCC));
        metricsForClass.add(new ClassMetricsMessageSingle(CE, cMetrics.getCe()));
        metricsForClass.add(new ClassMetricsMessageSingle(DAM, cMetrics.getDam()));
        metricsForClass.add(new ClassMetricsMessageSingle(DIT, cMetrics.getDit()));
        metricsForClass.add(new ClassMetricsMessageSingle(LCOM, cMetrics.getLcom()));
        metricsForClass.add(new ClassMetricsMessageSingle(LCOM3, cMetrics.getLcom3()));
        metricsForClass.add(new ClassMetricsMessageSingle(LOC, cMetrics.getLoc()));
        metricsForClass.add(new ClassMetricsMessageSingle(MOA, cMetrics.getMoa()));
        metricsForClass.add(new ClassMetricsMessageSingle(MFA, cMetrics.getMfa()));
        metricsForClass.add(new ClassMetricsMessageSingle(IC, cMetrics.getIc()));
        metricsForClass.add(new ClassMetricsMessageSingle(NOC, cMetrics.getNoc()));
        metricsForClass.add(new ClassMetricsMessageSingle(NPM, cMetrics.getNpm()));
        metricsForClass.add(new ClassMetricsMessageSingle(RFC, cMetrics.getRfc()));
        metricsForClass.add(new ClassMetricsMessageSingle(WMC, cMetrics.getWmc()));

        this.outputMetrics.add(new ClassMetricsEntry(className, metricsForClass));
    }

    /**
     * Retrieves the internally private Map ([method name, cc value]-pair)
     * for Cyclomatic Complexity metric.
     *
     * <p>The method goes through the list of method names of the given classMetrics
     * and for each method, it retrieves its corresponding Cyclomatic Complexity value
     * using the {@link ClassMetrics#getCC(String)} method and adds it to a
     * {@link ConcurrentHashMap} with the method name as the key and the CC value as the value.
     *
     * @param classMetrics the given classMetrics
     * @return a map containing CC-values for this class' methods
     */
    private Map<String, Integer> getCCMapInternal(final ClassMetrics classMetrics) {

        final List<String> methodNames = classMetrics.getMethodNames();
        final Map<String, Integer> metricValuesCC = new ConcurrentHashMap<>();
        for (final String methodName : methodNames) {
            metricValuesCC.put(methodName, classMetrics.getCC(methodName));
        }
        return metricValuesCC;
    }

    /**
     * Metrics enum representing all possible class metrics for the design checker.
     *
     * @author Jannik Seus
     */
    public enum Metric {

        AMC("Average Method Complexity"),
        CA("Afferent Coupling"),
        CAM("Cohesion Among Methods Of Class"),
        CBM("Coupling Between Methods"),
        CBO("Coupling Between Object Classes"),
        CC("McCabe's Cyclomatic Complexity"),
        CE("Efferent Coupling"),
        DAM("Data Access Metric"),
        DIT("Depth Of Inheritance Tree"),
        IC("Inheritance Coupling"),
        LCOM("Lack Of Cohesion In Methods"),
        LCOM3("Henderson-Sellers' Lack Of Cohesion In Methods"),
        LOC("Lines Of Code"),
        MFA("Measure Of Functional Abstraction"),
        MOA("Measure Of Aggregation"),
        NOC("Number Of Children"),
        NPM("Number Of Public Methods For A Class"),
        RFC("Response For A Class"),
        WMC("Weighted Methods Per Class");

        /**
         * The description of what this metric measures
         */
        private final String description;

        /**
         * Main constructor.
         * @param description (long) description for an abbreviation of a given metric
         */
        Metric(final String description) {
            this.description = description;
        }

        /**
         * Returns the description of the metric.
         * @return a string representing the description of the metric
         */
        public String getDescription() {
            return description;
        }
    }
}
